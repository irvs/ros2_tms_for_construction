#ifndef CONDITIONAL_EXPRESSION_NODE_HPP
#define CONDITIONAL_EXPRESSION_NODE_HPP

// Copyright 2023, IRVS Laboratory, Kyushu University, Japan.
// Licensed under the Apache License, Version 2.0 (the "License");

#include "rclcpp/rclcpp.hpp"
#include <thread>
#include <algorithm>
#include <cctype>
#include <sstream>
#include <unordered_set>
#include <regex>
#include "behaviortree_cpp_v3/action_node.h"
#include "exprtk.hpp"

using namespace BT;

static std::string trim(const std::string& s) {
    auto it1 = std::find_if_not(s.begin(), s.end(), [](char c){ return std::isspace((unsigned char)c); });
    auto it2 = std::find_if_not(s.rbegin(), s.rend(), [](char c){ return std::isspace((unsigned char)c); }).base();
    return (it1 < it2) ? std::string(it1, it2) : std::string();
}

class ConditionalExpression : public SyncActionNode
{
public:
    ConditionalExpression(const std::string& name, const NodeConfiguration& config)
      : SyncActionNode(name, config)
    {
        node_ = rclcpp::Node::make_shared("conditional_expression");
        spin_thread_ = std::thread([this](){ rclcpp::spin(node_); });
    }

    ~ConditionalExpression()
    {
        rclcpp::shutdown();
        if (spin_thread_.joinable()) spin_thread_.join();
    }

    static PortsList providedPorts()
    {
        return { InputPort<std::string>("conditional_expression") };
    }

    NodeStatus tick() override
    {
        Optional<std::string> opt = getInput<std::string>("conditional_expression");
        if (!opt) {
            RCLCPP_ERROR(node_->get_logger(), "[ConditionalExpression] Missing required input.");
            return NodeStatus::FAILURE;
        }
        bool result = false;
        if (!evaluateCondition(opt.value(), result)) {
            RCLCPP_ERROR(node_->get_logger(), "[ConditionalExpression] Evaluation error.");
            return NodeStatus::FAILURE;
        }
        return result ? NodeStatus::SUCCESS : NodeStatus::FAILURE;
    }

private:
    rclcpp::Node::SharedPtr node_;
    std::thread spin_thread_;

    bool evaluateCondition(std::string expr, bool& result)
    {
        auto bb = config().blackboard;
        RCLCPP_DEBUG(node_->get_logger(), "[ConditionalExpression] Raw expr: %s", expr.c_str());

        // 1) Substitute identifiers: non-quoted words for blackboard
        static const std::unordered_set<std::string> reserved = {
            "and","or","true","false","==","!=","<",">","<=",">="
        };
        static const std::regex word_re(R"REGEX([A-Za-z_]\w*)REGEX");
        static const std::regex num_re(R"REGEX(^[+-]?(?:\d+\.?\d*|\.\d+)$)REGEX");

        std::string out;
        size_t pos = 0;
        while (pos < expr.size()) {
            if (expr[pos] == '"' || (!std::isalpha(static_cast<unsigned char>(expr[pos])) && expr[pos] != '_')) {
                out += expr[pos++];
            } else {
                std::smatch wm;
                std::string tail(expr.begin()+pos, expr.end());
                if (std::regex_search(tail, wm, word_re) && wm.position() == 0) {
                    std::string tok = wm.str();
                    std::string sub = tok;
                    bool is_num  = std::regex_match(tok, num_re);
                    bool is_bool = (tok == "true" || tok == "false");
                    if (!reserved.count(tok) && !is_num && !is_bool) {
                        if (auto anyv = bb->getAny(tok)) {
                            if (anyv->type() == typeid(std::string)) {
                                sub = "\"" + anyv->cast<std::string>() + "\"";
                            } else if (anyv->type() == typeid(bool)) {
                                sub = anyv->cast<bool>() ? "true" : "false";
                            } else if (anyv->type() == typeid(int)) {
                                sub = std::to_string(anyv->cast<int>());
                            } else if (anyv->type() == typeid(double)) {
                                sub = std::to_string(anyv->cast<double>());
                            }
                        } else {
                            sub = "\"\"";
                        }
                    }
                    out += sub;
                    pos += tok.size();
                    continue;
                }
                out += expr[pos++];
            }
        }
        expr.swap(out);
        RCLCPP_DEBUG(node_->get_logger(), "[ConditionalExpression] After key subst: %s", expr.c_str());
        // prepare regex matcher for subsequent string comparisons
        std::smatch m;

        // 2) Pre-evaluate explicit string comparisons generated by substitution
        static const std::regex str_cmp_re(R"REGEX("([^"]*)"\s*(==|!=)\s*"([^"]*)")REGEX");
        while (std::regex_search(expr, m, str_cmp_re)) {
            std::string a  = m[1].str();
            std::string op = m[2].str();
            std::string b  = m[3].str();
            bool cmp = (op == "==") ? (a == b) : (a != b);
            expr = m.prefix().str() + (cmp ? "true" : "false") + m.suffix().str();
        }
        RCLCPP_DEBUG(node_->get_logger(), "[ConditionalExpression] After string cmp: %s", expr.c_str());

        // Log final expr before ExprTK
        RCLCPP_INFO(node_->get_logger(), "[ConditionalExpression] ExprTK input: %s", expr.c_str());

        // 3) Final evaluation via ExprTK
        typedef exprtk::symbol_table<double> symbol_table_t;
        typedef exprtk::expression<double>   expression_t;
        typedef exprtk::parser<double>       parser_t;
        symbol_table_t symbol_table;
        expression_t   expression;
        parser_t       parser;

        symbol_table.add_constant("true",  1.0);
        symbol_table.add_constant("false", 0.0);
        symbol_table.add_constants();
        expression.register_symbol_table(symbol_table);

        if (!parser.compile(expr, expression)) {
            RCLCPP_ERROR(node_->get_logger(), "[ConditionalExpression] ExprTK parse failed: %s", parser.error().c_str());
            return false;
        }
        double val = expression.value();
        result = (val != 0.0);
        RCLCPP_INFO(node_->get_logger(), "[ConditionalExpression] Final eval '%s' -> %s", expr.c_str(), result?"true":"false");
        return true;
    }
};

#endif // CONDITIONAL_EXPRESSION_NODE_HPP
